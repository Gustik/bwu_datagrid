{"name":"polymer_expressions-filter","qualifiedName":"polymer_expressions/polymer_expressions-filter","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"Transformer","qualifiedName":"polymer_expressions/polymer_expressions-filter.Transformer"}],"typedef":{"Filter":{"name":"Filter","qualifiedName":"polymer_expressions/polymer_expressions-filter.Filter","comment":"","return":"dart-core.Object","parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{}}},"error":[]},"packageName":"polymer_expressions","packageIntro":"<h1>polymer_expressions</h1>\n<p>Polymer expressions are an expressive syntax that can be used in HTML templates\nwith Dart.</p>\n<p>Templates are one feature of Polymer.dart, which is a set of comprehensive UI\nand utility components for building web applications.\nThis package is automatically included with the\n<a href=\"https://pub.dartlang.org/packages/polymer\">Polymer</a> package\nbecause Polymer expressions are the default expression syntax\nin Polymer Dart apps.\nThe [Polymer.dart homepage][home_page]\ncontains a list of features, project status,\ninstallation instructions, tips for upgrading from Web UI,\nand links to other documentation.</p>\n<h2>Overview</h2>\n<p>Polymer expressions allow you to write complex binding expressions, with\nproperty access, function invocation, list/map indexing, and two-way filtering\nlike:</p>\n<pre class=\"html\"><code>    {{ person.title + \" \" + person.getFullName() | upppercase }}\n</code></pre>\n<h3>Model-Driven Views (MDV)</h3>\n<p><a href=\"http://www.polymer-project.org/platform/mdv.html\">MDV</a> allows you to define templates directly in HTML that are rendered by\nthe browser into the DOM. Templates are bound to a data model, and changes to\nthe data are automatically reflected in the DOM, and changes in HTML inputs are\nassigned back into the model. The template and model are bound together via\nbinding expressions that are evaluated against the model. These binding\nexpressions are placed in double-curly-braces, or \"mustaches\".</p>\n<p>Example:</p>\n<pre class=\"html\"><code>    &lt;template&gt;\n      &lt;p&gt;Hello {{ person.name }}&lt;/p&gt;\n    &lt;/template&gt;\n</code></pre>\n<p>MDV includes a very basic binding syntax which only allows a series of\ndot-separate property names.</p>\n<h3>Custom binding syntaxes with binding delegate</h3>\n<p>While MDV's built-in syntax is very basic, it does allow custom syntaxes called\n\"binding delegates\" to be installed and used. A binding delegate can interpret\nthe contents of mustaches however it likes. PolymerExpressions is such a\nbinding delegate.</p>\n<p>Example:</p>\n<pre class=\"html\"><code>    &lt;template bind&gt;\n      &lt;p&gt;Hello {{ person.title + \" \" + person.getFullName() | uppercase }}&lt;/p&gt;\n    &lt;/template&gt;\n</code></pre>\n<h2>Usage</h2>\n<h3>Installing from Pub</h3>\n<p>Add the following to your pubspec.yaml file:</p>\n<pre class=\"yaml\"><code>    dependencies:\n      polymer_expressions: any\n</code></pre>\n<p>Hint: check https://pub.dartlang.org/packages/polymer_expressions for the latest\nversion number.</p>\n<p>Then import polymer_expressions.dart:</p>\n<pre><code>import 'package:polymer_expressions/polymer_expressions.dart';\n</code></pre>\n<h3>Registering a binding delegate</h3>\n<p><strong>Polymer Expressions are now the default syntax for <code>&lt;polymer-element&gt;</code> custom\nelements.</strong></p>\n<p>You do not need to manually register the bindingDelegate if your bindings are\ninside a custom element. However, if you want to use polymer_expressions outside\na custom element, read on:</p>\n<p>Binding delegates must be installed on a template before they can be used.\nFor example, set the bindingDelegate property of your template\nelements to an instance of PolymerExpressions. The templates will then use the\nPolymerExpressions instance to interpret\nbinding expressions.</p>\n<pre class=\"dart\"><code>    import 'dart:html';\n    import 'package:polymer_expressions/polymer_expressions.dart';\n\n    main() {\n      var template = query('#my_template');\n      template.bindingDelegate = new PolymerExpressions();\n    }\n</code></pre>\n<h3>Registering top-level variables</h3>\n<p>Before a top-level variable can be used, it must be registered. The\nPolymerExpressions constructor takes a map of named values to use as variables.</p>\n<pre class=\"dart\"><code>    main() {\n      var globals = {\n        'uppercase': (String v) =&gt; v.toUpperCase(),\n        'app_id': 'my_app_123',\n      };\n      var template = query('#my_template');\n      template.bindingDelegate = new PolymerExpressions(globals: globals);\n    }\n</code></pre>\n<h2>Features</h2>\n<h3>The model and scope</h3>\n<p>Polymer Expressions allow binding to more than just the model assigned to a\ntemplate instance. Top-level variables can be defined so that you can use\nfilters, global variables and constants, functions, etc. These variables and the\nmodel are held together in a container called a Scope. Scopes can be nested,\nwhich happens when template tags are nested.</p>\n<h3>Two-way bindings</h3>\n<p>Bindings can be used to modify the data model based on events in the DOM. The\nmost common case is to bind an &lt;input&gt; element's value field to a model\nproperty and have the property update when the input changes. For this to work,\nthe binding expression must be \"assignable\". Only a subset of expressions are\nassignable. Assignable expressions cannot contain function calls, operators, and\nany index operator must have a literal argument. Assignable expressions can\ncontain filter operators as long as all the filters are two-way transformers.</p>\n<p>Some restrictions may be relaxed further as allowed.</p>\n<p>Assignable Expressions:</p><ul><li><code>foo</code></li><li><code>foo.bar</code></li><li><code>items[0].description</code></li><li><code>people['john'].name</code></li><li>\n<p><code>product.cost | convertCurrency('ZWD')</code> where <code>convertCurrency</code> evaluates to\n   a Tranformer object.</p></li></ul>\n<p>Non-Assignable Expressions:</p><ul><li><code>a + 1</code></li><li><code>!c</code></li><li><code>foo()</code></li><li><code>person.lastName | uppercase</code> where <code>uppercase</code> is a filter function.</li></ul>\n<h3>Null-Safety</h3>\n<p>Expressions are generally null-safe. If an intermediate expression yields <code>null</code>\nthe entire expression will return null, rather than throwing an exception.\nProperty access, method invocation and operators are null-safe. Passing null to\na function that doesn't handle null will not be null safe.</p>\n<h3>Streams</h3>\n<p>Polymer Expressions have experimental support for binding to streams, and when\nnew values are passed to the stream, the template updates. The feature is not\nfully implemented yet.</p>\n<p>See the examples in /example/streams for more details.</p>\n<h2>Syntax</h2>\n<h3>Property access</h3>\n<p>Properties on the model and in the scope are looked up via simple property\nnames, like <code>foo</code>. Property names are looked up first in the top-level\nvariables, next in the model, then recursively in parent scopes. Properties on\nobjects can be access with dot notation like <code>foo.bar</code>.</p>\n<p>The keyword <code>this</code> always refers to the model if there is one, otherwise <code>this</code>\nis <code>null</code>. If you have model properties and top-level variables with the same\nname, you can use <code>this</code> to refer to the model property.</p>\n<h3>Literals</h3>\n<p>Polymer Expressions support number, boolean, string, and map literals. Strings\ncan use either single or double quotes.</p><ul><li>Numbers: <code>1</code>, <code>1.0</code></li><li>Booleans: <code>true</code>, <code>false</code></li><li>Strings: <code>'abc'</code>, <code>\"xyz\"</code></li><li>Maps: <code>{ 'a': 1, 'b': 2 }</code></li></ul>\n<p>List literals are planned, see <a href=\"https://github.com/dart-lang/polymer_expressions/issues/9\">issue 9</a></p>\n<h3>Functions and methods</h3>\n<p>If a property is a function in the scope, a method on the model, or a method on\nan object, it can be invoked with standard function syntax. Functions and\nMethods can take arguments. Named arguments are not supported. Arguments can be\nliterals or variables.</p>\n<p>Examples:</p><ul><li>Top-level function: <code>myFunction()</code></li><li>Top-level function with arguments: <code>myFunction(a, b, 42)</code></li><li>Model method: <code>aMethod()</code></li><li>Method on nested-property: <code>a.b.anotherMethod()</code></li></ul>\n<h3>Operators</h3>\n<p>Polymer Expressions supports the following binary and unary operators:</p><ul><li>Arithmetic operators: +, -, *, /, %, unary + and -</li><li>Comparison operators: ==, !=, &lt;=, &lt;, >, >=</li><li>Boolean operators: &amp;&amp;, ||, unary !</li></ul>\n<p>Expressions do not support bitwise operators such as &amp;, |, &lt;&lt; and >>, or increment/decrement operators (++ and --)</p>\n<h3>List and Map indexing</h3>\n<p>List and Map like objects can be accessed via the index operator: </p>\n<p>Examples:</p><ul><li><code>items[2]</code></li><li><code>people['john']</code></li></ul>\n<p>Unlike JavaScript, list and map contents are not generally available via\nproperty access. That is, the previous examples are not equivalent to <code>items.2</code>\nand <code>people.john</code>. This ensures that access to properties and methods on Lists\nand Maps is preserved.</p>\n<h3>Filters and transformers</h3>\n<p>A filter is a function that transforms a value into another, used via the pipe\nsyntax: <code>value | filter</code> Any function that takes exactly one argument can be\nused as a filter.</p>\n<p>Example:</p>\n<p>If <code>person.name</code> is \"John\", and a top-level function named <code>uppercase</code> has been\nregistered, then <code>person.name | uppercase</code> will have the value \"JOHN\".</p>\n<p>The pipe syntax is used rather than a regular function call so that we can\nsupport two-way bindings through transformers. A transformer is a filter that\nhas an inverse function. Transformers must extend or implement the <code>Transformer</code>\nclass, which has <code>forward()</code> and <code>reverse()</code> methods.</p>\n<h3>Repeating templates</h3>\n<p>A template can be repeated by using the \"repeat\" attribute with a binding. The\nbinding can either evaluate to an Iterable, in which case the template is\ninstantiated for each item in the iterable and the model of the instance is\nset to the item, or the binding can be a \"in\" iterator expression, in which\ncase a new variable is added to each scope.</p>\n<p>The following examples produce the same output.</p>\n<p>Evaluate to an iterable:</p>\n<pre class=\"html\"><code>    &lt;template repeat=\"{{ items }}\"&gt;\n      &lt;div&gt;{{ }}&lt;/div&gt;\n    &lt;/template&gt;\n</code></pre>\n<p>\"in\" expression:</p>\n<pre class=\"html\"><code>    &lt;template repeat=\"{{ item in items }}\"&gt;\n      &lt;div&gt;{{ item }}&lt;/div&gt;\n    &lt;/template&gt;\n</code></pre>\n<h2>Status</h2>\n<p>The syntax implemented is experimental and subject to change, in fact, it\n<strong>will</strong> change soon. The goal is to be compatible with Polymer's binding\nsyntax. We will announce breaking changes on the\n<a href=\"https://groups.google.com/a/dartlang.org/forum/#!forum/web-ui\">web-ui@dartlang.org mailing list</a>.</p>\n<p>Please <a href=\"http://dartbug.com/new\">file issues on Dart project page</a>\nfor any bugs you find or for feature requests. Make a note that it applies to\n\"package:polymer_expressions\"</p>\n<p>You can discuss Polymer Expressions on the\n<a href=\"https://groups.google.com/a/dartlang.org/forum/#!forum/web-ui\">web-ui@dartlang.org mailing list</a>.</p>"}