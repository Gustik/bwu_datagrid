{"name":"polymer","qualifiedName":"polymer/polymer","comment":"<p>Custom HTML tags, data binding, and templates for building\nstructured, encapsulated, client-side web apps.</p>\n<p>Polymer.dart, the next evolution of Web UI,\nis an in-progress Dart port of the\n<a href=\"http://www.polymer-project.org/\">Polymer project</a>.\nPolymer.dart compiles to JavaScript and runs across the modern web.</p>\n<p>To use polymer.dart in your application,\nfirst add a\n<a href=\"http://pub.dartlang.org/doc/dependencies.html\">dependency</a>\nto the app's pubspec.yaml file.\nInstead of using the open-ended <code>any</code> version specifier,\nwe recommend using a range of version numbers, as in this example:</p>\n<pre><code>dependencies:\n  polymer: '&gt;=0.7.1 &lt;0.8'\n</code></pre>\n<p>Then import the library into your application:</p>\n<pre><code>import 'package:polymer/polymer.dart';\n</code></pre>\n<h2>Other resources</h2><ul><li>\n<p><a href=\"http://www.dartlang.org/polymer-dart/\">Polymer.dart homepage</a>:\nExample code, project status, and\ninformation about how to get started using Polymer.dart in your apps.</p></li><li>\n<p><a href=\"http://pub.dartlang.org/packages/polymer\">polymer.dart package</a>:\nMore details, such as the current major release number.</p></li><li>\n<p><a href=\"http://www.dartlang.org/polymer-dart/upgrading-to-polymer-from-web-ui.html\">Upgrading to Polymer.dart</a>:\nTips for converting your apps from Web UI to Polymer.dart.</p></li></ul>","variables":{"initMethod":{"name":"initMethod","qualifiedName":"polymer/polymer.initMethod","comment":"<p>Metadata used to label static or top-level methods that are called\nautomatically when loading the library of a custom element.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"observable":{"name":"observable","qualifiedName":"observe/observe.observable","comment":"<p>Use <code>@observable</code> to make a field automatically observable, or to indicate\nthat a property is observable.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"observe/observe.ObservableProperty","inner":[]}],"annotations":[]},"published":{"name":"published","qualifiedName":"polymer/polymer.published","comment":"<p>Use this annotation to publish a field as an attribute. For example:</p>\n<pre><code>class MyPlaybackElement extends PolymerElement {\n  // This will be available as an HTML attribute, for example:\n  //     &lt;my-playback volume=\"11\"&gt;\n  @published double volume;\n}\n</code></pre>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"reflectable":{"name":"reflectable","qualifiedName":"observe/observe.reflectable","comment":"<p>Use <code>@reflectable</code> to make a type or member available to reflection in the\nobserve package. This is necessary to make the member visible to\nPathObserver, or similar systems, once the code is deployed.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"observe/observe.Reflectable","inner":[]}],"annotations":[]},"windowLocation":{"name":"windowLocation","qualifiedName":"observe/observe-html.windowLocation","comment":"<p>An observable version of window.location.hash.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"observe/observe-html.ObservableLocationHash","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"bindCssClass":{"name":"bindCssClass","qualifiedName":"polymer/polymer.bindCssClass","comment":"<p><em>Deprecated</em> use <code>class=\"{{ binding }}\"</code> in your HTML instead. It will also\nwork on a <code>&lt;polymer-element&gt;</code>.</p>\n<p>Bind a CSS class to the observable <a>polymer/polymer.bindCssClass.object</a> and property <a>polymer/polymer.bindCssClass.path</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"polymer/polymer.PathObserver","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"polymer/polymer.Element","inner":[]}],"value":null,"annotations":[]},"className":{"name":"className","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"object":{"name":"object","optional":false,"named":false,"default":false,"type":[{"outer":"polymer/polymer.Observable","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[{"name":"polymer/dart-core.deprecated","parameters":[]}]},"initPolymer":{"name":"initPolymer","qualifiedName":"polymer/polymer.initPolymer","comment":"<p>This method is deprecated. It used to be where polymer initialization\nhappens, now this is done automatically from bootstrap.dart.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Zone","inner":[]}],"parameters":{},"annotations":[{"name":"polymer/dart-core.deprecated","parameters":[]}]},"onPropertyChange":{"name":"onPropertyChange","qualifiedName":"polymer/polymer.onPropertyChange","comment":"<p>Forwards an observable property from one object to another. For example:</p>\n<pre><code>class MyModel extends Observable {\n  StreamSubscription _sub;\n  MyOtherModel _otherModel;\n\n  MyModel() {\n    ...\n    _sub = onPropertyChange(_otherModel, #value,\n        () =&gt; notifyProperty(this, #prop);\n  }\n\n  String get prop =&gt; _otherModel.value;\n  set prop(String value) { _otherModel.value = value; }\n}\n</code></pre>\n<p>See also notifyProperty.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.StreamSubscription","inner":[]}],"parameters":{"source":{"name":"source","optional":false,"named":false,"default":false,"type":[{"outer":"polymer/polymer.Observable","inner":[]}],"value":null,"annotations":[]},"sourceName":{"name":"sourceName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"startPolymer":{"name":"startPolymer","qualifiedName":"polymer/polymer.startPolymer","comment":"<p>Starts polymer by running all <a>polymer/polymer.startPolymer.initializers</a> and hooking the polymer.js\ncode. <strong>Note</strong>: this function is not meant to be invoked directly by\napplication developers. It is invoked by a bootstrap entry point that is\nautomatically generated. During development, this entry point is generated\ndynamically in <code>boot.js</code>. Similarly, pub-build generates this entry point\nfor deployment.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"initializers":{"name":"initializers","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.Function","inner":[]}]}],"value":null,"annotations":[]},"deployMode":{"name":"deployMode","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"toObservable":{"name":"toObservable","qualifiedName":"polymer/polymer.toObservable","comment":"<p>Converts the <a>dart-core.Iterable</a> or <a>dart-core.Map</a> to an <a>polymer/polymer.ObservableList</a> or <a>polymer/polymer.ObservableMap</a>,\nrespectively. This is a convenience function to make it easier to convert\nliterals into the corresponding observable collection type.</p>\n<p>If <a>polymer/polymer.toObservable.value</a> is not one of those collection types, or is already <a>polymer/polymer.Observable</a>,\nit will be returned unmodified.</p>\n<p>If <a>polymer/polymer.toObservable.value</a> is a <a>dart-core.Map</a>, the resulting value will use the appropriate kind of\nbacking map: either <a>polymer/dart-collection.HashMap</a>, <a>polymer/dart-core</a>, or <a>polymer/dart-core</a>.</p>\n<p>By default this performs a deep conversion, but you can set <a>polymer/polymer.toObservable.deep</a> to false\nfor a shallow conversion. This does not handle circular data structures.\nIf a conversion is peformed, mutations are only observed to the result of\nthis function. Changing the original collection will not affect it.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"deep":{"name":"deep","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"updateCssClass":{"name":"updateCssClass","qualifiedName":"polymer/polymer.updateCssClass","comment":"<p><em>Deprecated</em> use <a>polymer/dart-dom-html.CssClassSet.toggle</a> instead.</p>\n<p>Add or remove CSS class <a>polymer/polymer.updateCssClass.className</a> based on the <a>polymer/polymer.updateCssClass.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"polymer/polymer.Element","inner":[]}],"value":null,"annotations":[]},"className":{"name":"className","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[{"name":"polymer/dart-core.deprecated","parameters":[]}]}}},"classes":{"class":[{"name":"Bindable","qualifiedName":"polymer/polymer.Bindable","preview":"<p>An object that can be data bound.</p>"},{"name":"ChangeNotifier","qualifiedName":"polymer/polymer.ChangeNotifier","preview":"<p>Mixin and base class for implementing an <a>polymer/polymer.Observable</a> object that performs\nits own change notifications, and does not need to be considered by\n<a>polymer/polymer.Observable.dirtyCheck</a>.</p>"},{"name":"ChangeRecord","qualifiedName":"polymer/polymer.ChangeRecord","preview":"<p>Records a change to an <a>polymer/polymer.Observable</a>.</p>"},{"name":"CompoundObserver","qualifiedName":"polymer/polymer.CompoundObserver","preview":"<p><a>polymer/polymer.CompoundObserver</a> is a <a>polymer/polymer.Bindable</a> object which knows how to listen to\nmultiple values (registered via <a>polymer/polymer.CompoundObserver.addPath</a> or <a>polymer/polymer.CompoundObserver.addObserver</a>) and invoke a\ncallback when one or more of the values have changed.</p>"},{"name":"CustomTag","qualifiedName":"polymer/polymer.CustomTag","preview":"<p>Annotation used to automatically register polymer elements.</p>"},{"name":"Indexable","qualifiedName":"polymer/polymer.Indexable","preview":"<p>An object accepted by <a>polymer/polymer.PropertyPath</a> where properties are read and written\nas indexing operations, just like a <a>polymer/dart-core.Map</a>.</p>"},{"name":"InitMethodAnnotation","qualifiedName":"polymer/polymer.InitMethodAnnotation","preview":"<p>Implementation behind <a>polymer/polymer.initMethod</a>. Only exposed for internal implementation\ndetails</p>"},{"name":"ListChangeRecord","qualifiedName":"polymer/polymer.ListChangeRecord","preview":"<p>A summary of an individual change to a <a>polymer/dart-core.List</a>.</p>"},{"name":"ListPathObserver","qualifiedName":"polymer/polymer.ListPathObserver","preview":"<p>Observes a path starting from each item in the list.</p>"},{"name":"MapChangeRecord","qualifiedName":"polymer/polymer.MapChangeRecord"},{"name":"Observable","qualifiedName":"polymer/polymer.Observable","preview":"<p>Represents an object with observable properties. This is used by data in\nmodel-view architectures to notify interested parties of <a>polymer/polymer.Observable.changes</a> to the\nobject's properties (fields or getter/setter pairs).</p>"},{"name":"ObservableBox","qualifiedName":"polymer/polymer.ObservableBox","preview":"<p>An observable box that holds a value. Use this if you want to store a single\nvalue. For other cases, it is better to use <a>polymer/polymer.ObservableList</a>,\n<a>polymer/polymer.ObservableMap</a>, or a custom <a>polymer/polymer.Observable</a> implementation based on\n<a>polymer/polymer.Observable</a>. The property name for changes is \"value\".</p>"},{"name":"ObservableList","qualifiedName":"polymer/polymer.ObservableList","preview":"<p>Represents an observable list of model values. If any items are added,\nremoved, or replaced, then observers that are listening to <a>polymer/polymer.ChangeNotifier.changes</a>\nwill be notified.</p>"},{"name":"ObservableLocationHash","qualifiedName":"polymer/polymer.ObservableLocationHash"},{"name":"ObservableMap","qualifiedName":"polymer/polymer.ObservableMap","preview":"<p>Represents an observable map of model values. If any items are added,\nremoved, or replaced, then observers that are listening to <a>polymer/polymer.ChangeNotifier.changes</a>\nwill be notified.</p>"},{"name":"ObservableProperty","qualifiedName":"polymer/polymer.ObservableProperty","preview":"<p>An annotation that is used to make a property observable.\nNormally this is used via the <a>polymer/observe-src-metadata.observable</a> constant, for example:</p>"},{"name":"ObserveProperty","qualifiedName":"polymer/polymer.ObserveProperty","preview":"<p>Use this type to observe a property and have the method be called when it\nchanges. For example:</p>"},{"name":"ObserverTransform","qualifiedName":"polymer/polymer.ObserverTransform","preview":"<p>ObserverTransform is used to dynamically transform observed value(s).</p>"},{"name":"PathObserver","qualifiedName":"polymer/polymer.PathObserver","preview":"<p>A data-bound path starting from a view-model or model object, for example\n<code>foo.bar.baz</code>.</p>"},{"name":"Polymer","qualifiedName":"polymer/polymer.Polymer","preview":"<p>The mixin class for Polymer elements. It provides convenience features on\ntop of the custom elements web standard.</p>"},{"name":"PolymerDeclaration","qualifiedName":"polymer/polymer.PolymerDeclaration","preview":"<p><em>Warning</em> this class is experimental and subject to change.</p>"},{"name":"PolymerElement","qualifiedName":"polymer/polymer.PolymerElement","preview":"<p>Base class for PolymerElements deriving from HtmlElement.</p>"},{"name":"PolymerExpressionsWithEvents","qualifiedName":"polymer/polymer.PolymerExpressionsWithEvents"},{"name":"PropertyChangeRecord","qualifiedName":"polymer/polymer.PropertyChangeRecord","preview":"<p>A change record to a field of an observable object.</p>"},{"name":"PropertyPath","qualifiedName":"polymer/polymer.PropertyPath","preview":"<p>A dot-delimieted property path such as \"foo.bar\" or \"foo.10.bar\".</p>"},{"name":"PublishedProperty","qualifiedName":"polymer/polymer.PublishedProperty","preview":"<p>An annotation used to publish a field as an attribute. See <a>polymer/polymer.published</a>.</p>"},{"name":"Reflectable","qualifiedName":"polymer/polymer.Reflectable","preview":"<p>An annotation that is used to make a type or member reflectable. This makes\nit available to <a>polymer/polymer.PathObserver</a> at runtime. For example:</p>"}],"typedef":{},"error":[]},"packageName":"polymer","packageIntro":"<h1>Polymer.dart</h1>\n<p>Polymer.dart is a set of comprehensive UI and utility components\nfor building web applications.\nWith Polymer.dart's custom elements, templating, data binding,\nand other features,\nyou can quickly build structured, encapsulated, client-side web apps.</p>\n<p>Polymer.dart is a Dart port of\n<a href=\"http://www.polymer-project.org/\">Polymer</a> created and maintained by the Dart team.\nThe Dart team is collaborating with the Polymer team to ensure that polymer.dart\nelements and polyfills are fully compatible with Polymer.</p>\n<p>Polymer.dart replaces Web UI, which has been deprecated.</p>\n<h2>Learn More</h2><ul><li>\n<p>The <a href=\"https://www.dartlang.org/polymer-dart/\">Polymer.dart</a> homepage\ncontains a list of features, project status,\ninstallation instructions, tips for upgrading from Web UI,\nand links to other documentation.</p></li><li>\n<p>See our <a href=\"http://addyosmani.github.com/todomvc/\">TodoMVC</a> example by opening up the Dart Editor's Welcome Page and\nselecting \"TodoMVC\".</p></li><li>\n<p>For more information about Dart, see <a href=\"http://www.dartlang.org/\">http://www.dartlang.org/</a>.</p></li><li>\n<p>When you use this package,\nyou automatically get the\n<a href=\"http://pub.dartlang.org/packages/polymer_expressions/\">polymer_expressions</a> package,\nwhich provides an expressive syntax for use with templates.</p></li></ul>\n<h2>Try It Now</h2>\n<p>Add the polymer.dart package to your pubspec.yaml file:</p>\n<pre class=\"yaml\"><code>dependencies:\n  polymer: \"&gt;=0.9.0 &lt;0.10.0\"\n</code></pre>\n<p>Instead of using <code>any</code>, we recommend using version ranges to avoid getting your\nproject broken on each release. Using a version range lets you upgrade your\npackage at your own pace. You can find the latest version number at\n<a href=\"https://pub.dartlang.org/packages/polymer\">https://pub.dartlang.org/packages/polymer</a>.</p>\n<h2>Building and Deploying</h2>\n<p>To build a deployable version of your app, add the polymer transformers to your\npubspec.yaml file:</p>\n<pre class=\"yaml\"><code>transformers:\n- polymer\n</code></pre>\n<p>Then, run <code>pub build</code>.  The polymer transformers assume all files under <code>web</code>\nare possible entry points, this can be adjusted with arguments in your\npubspec.yaml file. For example, you can say only <code>web/index.html</code> is an entry\npoint as follows:</p>\n<pre class=\"yaml\"><code>transformers:\n- polymer:\n    entry_points: web/index.html\n</code></pre>\n<p>Here is a list of arguments used by the polymer transformers:\n* js: whether to load JS code directly. By default polymer converts your app's\n  html file to load the compiled JS code directly. Setting this parameter to\n  false will keep a dart script tag and the <code>dart.js</code> script tag on the page.</p><ul><li>\n<p>csp: whether to load a Content Security Policy (CSP) compliant JS file.\n  Dart2js generates two JS files, one that is not CSP compilant and one that is.\n  By default, polymer uses the former becuase it's likely more efficient, but\n  you can choose the latter by setting this flag.</p></li><li>\n<p>entry_points: can be a list of entry points or, for convenience, a single\n  entry point as shown above.</p></li></ul>\n<p>For example, this specification includes 2 entrypoints and chooses the CSP\ncompliant JS file:</p>\n<pre class=\"yaml\"><code>transformers:\n- polymer:\n    entry_points:\n    - web/index.html\n    - web/index2.html\n    csp: true\n</code></pre>\n<h2>Contacting Us</h2>\n<p>Please file issues in our <a href=\"http://dartbug.com/new\">Issue Tracker</a> or contact us on the\n<a href=\"https://groups.google.com/a/dartlang.org/forum/?fromgroups#!forum/web-ui\">Dart Web UI mailing list</a>.</p>\n<p>We also have the <a href=\"https://groups.google.com/a/dartlang.org/forum/?fromgroups#!forum/web-ui-dev\">Web UI development list</a> for discussions about\ninternals of the code, code reviews, etc.</p>"}