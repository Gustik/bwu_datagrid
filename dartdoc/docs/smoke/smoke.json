{"name":"smoke","qualifiedName":"smoke/smoke","comment":"<p>Collects services that can be used to access objects dynamically, inspect\ntype information, and convert between symbols and strings.</p>","variables":{"FIELD":{"name":"FIELD","qualifiedName":"smoke/smoke.FIELD","comment":"<p>Declaration kind used to denote a raw field.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"METHOD":{"name":"METHOD","qualifiedName":"smoke/smoke.METHOD","comment":"<p>Declaration kind used to denote a method.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PROPERTY":{"name":"PROPERTY","qualifiedName":"smoke/smoke.PROPERTY","comment":"<p>Declaration kind used to denote a getter/setter.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"SUPPORTED_ARGS":{"name":"SUPPORTED_ARGS","qualifiedName":"smoke/smoke.SUPPORTED_ARGS","comment":"<p>Number of arguments supported by <a>smoke/smoke.minArgs</a> and <a>smoke/smoke.maxArgs</a>.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"configure":{"name":"configure","qualifiedName":"smoke/smoke.configure","comment":"<p>Configures this library to use <a>smoke/smoke.configure.objectAccessor</a> for all read/write/invoke\nAPIs, <a>smoke/smoke.configure.typeInspector</a> for all type query APIs, and <a>smoke/smoke.configure.symbolConverter</a> for all\nsymbol convertion operations.</p>\n<p>This function doesn't need to be called during development, but frameworks\nshould autogenerate a call to this function when running in deployment.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"objectAccessor":{"name":"objectAccessor","optional":false,"named":false,"default":false,"type":[{"outer":"smoke/smoke.ObjectAccessorService","inner":[]}],"value":null,"annotations":[]},"typeInspector":{"name":"typeInspector","optional":false,"named":false,"default":false,"type":[{"outer":"smoke/smoke.TypeInspectorService","inner":[]}],"value":null,"annotations":[]},"symbolConverter":{"name":"symbolConverter","optional":false,"named":false,"default":false,"type":[{"outer":"smoke/smoke.SymbolConverterService","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getDeclaration":{"name":"getDeclaration","qualifiedName":"smoke/smoke.getDeclaration","comment":"<p>Get the declaration associated with field <a>smoke/smoke.getDeclaration.name</a> found in <a>smoke/smoke.getDeclaration.type</a> or a\nsuperclass of <a>smoke/smoke.getDeclaration.type</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"smoke/smoke.Declaration","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasGetter":{"name":"hasGetter","qualifiedName":"smoke/smoke.hasGetter","comment":"<p>Tells whether <a>smoke/smoke.hasGetter.type</a> has a field or getter for <a>smoke/smoke.hasGetter.field</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"field":{"name":"field","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasInstanceMethod":{"name":"hasInstanceMethod","qualifiedName":"smoke/smoke.hasInstanceMethod","comment":"<p>Tells whether <a>smoke/smoke.hasInstanceMethod.type</a> has or a superclass contains a specific instance\n<a>smoke/smoke.hasInstanceMethod.method</a> (excluding methods in <a>dart-core.Object</a>).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasNoSuchMethod":{"name":"hasNoSuchMethod","qualifiedName":"smoke/smoke.hasNoSuchMethod","comment":"<p>Tells whether <a>smoke/smoke.hasNoSuchMethod.type</a> or a superclass (other than <a>dart-core.Object</a>) defines\n<code>noSuchMethod</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasSetter":{"name":"hasSetter","qualifiedName":"smoke/smoke.hasSetter","comment":"<p>Tells whether <a>smoke/smoke.hasSetter.type</a> has a field or setter for <a>smoke/smoke.hasSetter.field</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"field":{"name":"field","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasStaticMethod":{"name":"hasStaticMethod","qualifiedName":"smoke/smoke.hasStaticMethod","comment":"<p>Tells whether <a>smoke/smoke.hasStaticMethod.type</a> has a specific static <a>smoke/smoke.hasStaticMethod.method</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"invoke":{"name":"invoke","qualifiedName":"smoke/smoke.invoke","comment":"<p>Invoke <a>smoke/smoke.invoke.method</a> in <a>smoke/smoke.invoke.receiver</a> with <a>smoke/smoke.invoke.args</a>. The <a>smoke/smoke.invoke.receiver</a> can be either an\nobject (to invoke instance methods) or a type (to invoke static methods).\nThis function optionally <a>smoke/smoke.invoke.adjust</a>s the list of arguments to match the number\nof formal parameters by either adding nulls for missing arguments, or by\ntruncating the list.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"receiver":{"name":"receiver","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"args":{"name":"args","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"namedArgs":{"name":"namedArgs","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"adjust":{"name":"adjust","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"isSubclassOf":{"name":"isSubclassOf","qualifiedName":"smoke/smoke.isSubclassOf","comment":"<p>Tells whether <a>smoke/smoke.isSubclassOf.type</a> is transitively a subclass of <a>smoke/smoke.isSubclassOf.supertype</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"supertype":{"name":"supertype","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"maxArgs":{"name":"maxArgs","qualifiedName":"smoke/smoke.maxArgs","comment":"<p>Returns the maximum number of arguments that <a>smoke/smoke.maxArgs.f</a> takes as input, which is\nthe total number of required and optional arguments of <a>smoke/smoke.maxArgs.f</a>. If\n<a>smoke/smoke.maxArgs.f</a> may take more than <a>smoke/smoke.SUPPORTED_ARGS</a> required arguments, this function\nreturns <code>-1</code>. However, if it takes less required arguments, but more than\n<a>smoke/smoke.SUPPORTED_ARGS</a> arguments including optional arguments, the result will be\n<a>smoke/smoke.SUPPORTED_ARGS</a>.</p>\n<p>For instance, the current implementation only supports calculating the\nnumber of arguments between <code>0</code> and <code>3</code>.  If the function takes <code>4</code>\nmandatory arguments, this function returns <code>-1</code>, but if the funtion takes\n<code>2</code> mandatory arguments and 10 optional arguments, this function returns\n<code>3</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"minArgs":{"name":"minArgs","qualifiedName":"smoke/smoke.minArgs","comment":"<p>Returns the minimum number of arguments that <a>smoke/smoke.minArgs.f</a> takes as input, in other\nwords, the total number of required arguments of <a>smoke/smoke.minArgs.f</a>. If <a>smoke/smoke.minArgs.f</a> expects more\nthan <a>smoke/smoke.SUPPORTED_ARGS</a>, this function returns <code>SUPPORTED_ARGS + 1</code>.</p>\n<p>For instance, the current implementation only supports calculating the\nnumber of arguments between <code>0</code> and <code>3</code>. If the function takes <code>4</code> or more,\nthis function automatically returns <code>4</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"nameToSymbol":{"name":"nameToSymbol","qualifiedName":"smoke/smoke.nameToSymbol","comment":"<p>Returns the symbol associated with a <a>smoke/smoke.nameToSymbol.name</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Symbol","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"query":{"name":"query","qualifiedName":"smoke/smoke.query","comment":"<p>Retrieve all symbols of <a>smoke/smoke.query.type</a> that match <a>smoke/smoke.query.options</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"smoke/smoke.Declaration","inner":[]}]}],"parameters":{"type":{"name":"type","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Type","inner":[]}],"value":null,"annotations":[]},"options":{"name":"options","optional":false,"named":false,"default":false,"type":[{"outer":"smoke/smoke.QueryOptions","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"read":{"name":"read","qualifiedName":"smoke/smoke.read","comment":"<p>Return the value of <a>smoke/smoke.read.field</a> in <a>smoke/smoke.read.object</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"object":{"name":"object","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]},"field":{"name":"field","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"symbolToName":{"name":"symbolToName","qualifiedName":"smoke/smoke.symbolToName","comment":"<p>Returns the name associated with a <a>smoke/smoke.symbolToName.symbol</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"symbol":{"name":"symbol","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"write":{"name":"write","qualifiedName":"smoke/smoke.write","comment":"<p>Update the <a>smoke/smoke.write.value</a> of <a>smoke/smoke.write.field</a> in <a>smoke/smoke.write.object</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"object":{"name":"object","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]},"field":{"name":"field","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Declaration","qualifiedName":"smoke/smoke.Declaration","preview":"<p>Information associated with a symbol declaration (like a property or\nmethod).</p>"},{"name":"DeclarationKind","qualifiedName":"smoke/smoke.DeclarationKind","preview":"<p>Enumeration for declaration kinds (field, property, or method)</p>"},{"name":"ObjectAccessorService","qualifiedName":"smoke/smoke.ObjectAccessorService","preview":"<p>A service that provides a way to implement simple operations on objects like\nread, write, and invoke.</p>"},{"name":"QueryOptions","qualifiedName":"smoke/smoke.QueryOptions","preview":"<p>Establishes the parameters for <a>smoke/smoke.query</a> to search for symbols in a type\nhierarchy. For now only public instance symbols can be queried (no private,\nno static).</p>"},{"name":"SymbolConverterService","qualifiedName":"smoke/smoke.SymbolConverterService","preview":"<p>A service that converts between <a>smoke/dart-core.Symbol</a>s and <a>smoke/dart-core.String</a>s.</p>"},{"name":"TypeInspectorService","qualifiedName":"smoke/smoke.TypeInspectorService","preview":"<p>A service that provides partial inspection into Dart types.</p>"}],"typedef":{"NameMatcher":{"name":"NameMatcher","qualifiedName":"smoke/smoke.NameMatcher","comment":"<p>Used to filter query results based on a predicate on name. Returns true if\nname should be included in the query results.</p>","return":"dart-core.bool","parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>Used to filter query results based on a predicate on name. Returns true if\nname should be included in the query results.</p>"}},"error":[]},"packageName":"smoke","packageIntro":"<h1>Smoke (and mirrors)</h1>\n<p>Smoke is a package that exposes a reduced reflective system API. This API\nincludes accessing objects in a dynamic fashion (read properties, write\nproperties, and call methods), inspecting types (for example, whether a\nmethod exists), and symbol/string convertion.</p>\n<p>The package provides a default implementation of this API that uses the system's\nmirrors, but additionally provides mechanisms for statically generating code\nthat can replace the mirror-based implementation.</p>\n<p>The intention of this package is to allow frameworks to use mirrors in a way\nthat will not impose on their users. The idea is that users will not worry about\nhow to preserve symbols when compiling with dart2js (for instance, using the\n<a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-mirrors.MirrorsUsed\">MirrorsUsed</a> annotation). Instead, this package provides the building\nblocks to autogenerate whatever is needed for dart2js to be happy and to\ngenerate reasonable code.</p>\n<p>Note this package alone doesn't know how to generate everything, but it provides\na simple API that different frameworks can use to define what needs to be\ngenerated.</p>\n<h1>Smoke reflective API</h1>\n<p>Use <code>package:smoke/smoke.dart</code> in your framework to read and write objects and\nto inspect type information. Read the Dart-docs for more details.</p>\n<h1>Code Generation</h1>\n<p>TBD. We envision we'll have a base transformer class that can be tailored to\ncreate a transformer for your framework.</p>"}