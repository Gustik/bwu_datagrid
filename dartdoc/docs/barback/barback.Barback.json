{"name":"Barback","qualifiedName":"barback/barback.Barback","comment":"<p>A general-purpose asynchronous build dependency graph manager.</p>\n<p>It consumes source assets (including Dart files) in a set of packages,\nruns transformations on them, and then tracks which sources have been\nmodified and which transformations need to be re-run.</p>\n<p>To do this, you give barback a <a>barback/barback.PackageProvider</a> which can yield a set of\n<a>barback/barback.Transformer</a>s and raw source <a>barback/barback.Asset</a>s. Then you tell it which input files\nhave been added or modified by calling <a>barback/barback.Barback.updateSources</a>. Barback will\nautomatically wire up the appropriate transformers to those inputs and\nstart running them asynchronously. If a transformer produces outputs that\ncan be consumed by other transformers, they will automatically be pipelined\ncorrectly.</p>\n<p>You can then request assets (either source or generated) by calling\n<a>barback/barback.Barback.getAssetById</a>. This will wait for any necessary transformations and then\nreturn the asset.</p>\n<p>When source files have been modified or removed, tell barback by calling\n<a>barback/barback.Barback.updateSources</a> and <a>barback/barback.Barback.removeSources</a> as appropriate. Barback will\nautomatically track which transformations are affected by those changes and\nre-run them as needed.</p>\n<p>Barback tries to be resilient to errors since assets are often in an\nin-progress state. When errors occur, they will be captured and emitted on\nthe <a>barback/barback.Barback.errors</a> stream.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"errors":{"name":"errors","qualifiedName":"barback/barback.Barback.errors","comment":"<p>A stream that emits any errors from the graph or the transformers.</p>\n<p>This emits errors as they're detected. If an error occurs in one part of\nthe graph, unrelated parts will continue building.</p>\n<p>This will not emit programming errors from barback itself. Those will be\nemitted through the <a>barback/barback.Barback.results</a> stream's error channel.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[]}],"parameters":{},"annotations":[]},"log":{"name":"log","qualifiedName":"barback/barback.Barback.log","comment":"<p>The stream of <a>barback/barback.LogEntry</a> objects used to report transformer log entries.</p>\n<p>If this stream has listeners, then log entries will go to that.\nOtherwise, a default logger will display them.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"barback/barback.LogEntry","inner":[]}]}],"parameters":{},"annotations":[]},"results":{"name":"results","qualifiedName":"barback/barback.Barback.results","comment":"<p>A stream that emits a <a>barback/barback.BuildResult</a> each time the build is completed,\nwhether or not it succeeded.</p>\n<p>This will emit a result only once every package's AssetCascade has\nfinished building.</p>\n<p>If an unexpected error in barback itself occurs, it will be emitted\nthrough this stream's error channel.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"barback/barback.BuildResult","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"barback/barback.Barback.Barback-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"provider":{"name":"provider","optional":false,"named":false,"default":false,"type":[{"outer":"barback/barback.PackageProvider","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"getAllAssets":{"name":"getAllAssets","qualifiedName":"barback/barback.Barback.getAllAssets","comment":"<p>Gets all output assets.</p>\n<p>If a build is currently in progress, waits until it completes. The\nreturned future will complete with a <a>barback/barback.BarbackException</a> if the build is\nnot successful.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"barback/barback.AssetSet","inner":[]}]}],"parameters":{},"annotations":[]},"getAssetById":{"name":"getAssetById","qualifiedName":"barback/barback.Barback.getAssetById","comment":"<p>Gets the asset identified by <a>barback/barback.Barback.getAssetById.id</a>.</p>\n<p>If <a>barback/barback.Barback.getAssetById.id</a> is for a generated or transformed asset, this will wait until\nit has been created and return it. If the asset cannot be found, throws\n<a>barback/barback.AssetNotFoundException</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"barback/barback.Asset","inner":[]}]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"barback/barback.AssetId","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"removeSources":{"name":"removeSources","qualifiedName":"barback/barback.Barback.removeSources","comment":"<p>Removes <a>barback/barback.Barback.removeSources.removed</a> from the graph's known set of source assets.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"removed":{"name":"removed","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"barback/barback.AssetId","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"updateSources":{"name":"updateSources","qualifiedName":"barback/barback.Barback.updateSources","comment":"<p>Adds <a>barback/barback.Barback.updateSources.sources</a> to the graph's known set of source assets.</p>\n<p>Begins applying any transforms that can consume any of the sources. If a\ngiven source is already known, it is considered modified and all\ntransforms that use it will be re-applied.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"sources":{"name":"sources","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"barback/barback.AssetId","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"updateTransformers":{"name":"updateTransformers","qualifiedName":"barback/barback.Barback.updateTransformers","comment":"<p>Sets the transformer phases for <a>barback/barback.Barback.updateTransformers.package</a>'s assets to <a>barback/barback.Barback.updateTransformers.transformers</a>.</p>\n<p>To the extent that <a>barback/barback.Barback.updateTransformers.transformers</a> is similar to the previous transformer\nphases for <a>barback/barback.Barback.updateTransformers.package</a>, the existing asset graph will be preserved.</p>\n<p>Elements of the inner iterable of <a>barback/barback.Barback.updateTransformers.transformers</a> must be either\n<a>barback/barback.Transformer</a>s or TransformerGroups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"package":{"name":"package","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"transformers":{"name":"transformers","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Iterable","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"barback/barback.Barback.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>barback/barback.Barback.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"barback/barback.Barback.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"barback/barback.Barback.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>barback/barback.Barback.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>barback/barback.Barback.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"barback/barback.Barback.noSuchMethod","comment":"<p><a>barback/barback.Barback.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>barback/barback.Barback.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>barback/barback.Barback.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>barback/barback.Barback.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"barback/barback.Barback.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}