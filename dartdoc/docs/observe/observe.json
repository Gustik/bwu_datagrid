{"name":"observe","qualifiedName":"observe/observe","comment":"<p>Support for observing changes in model-view architectures.</p>\n<p><strong>Warning:</strong> This library is experimental, and APIs are subject to change.</p>\n<p>This library is used to observe changes to Observable types. It also\nhas helpers to make implementing and using Observable objects easy.</p>\n<p>You can provide an observable object in two ways. The simplest way is to\nuse dirty checking to discover changes automatically:</p>\n<pre><code>import 'package:observe/observe.dart';\nimport 'package:observe/mirrors_used.dart'; // for smaller code\n\nclass Monster extends Unit with Observable {\n  @observable int health = 100;\n\n  void damage(int amount) {\n    print('$this takes $amount damage!');\n    health -= amount;\n  }\n\n  toString() =&gt; 'Monster with $health hit points';\n}\n\nmain() {\n  var obj = new Monster();\n  obj.changes.listen((records) {\n    print('Changes to $obj were: $records');\n  });\n  // No changes are delivered until we check for them\n  obj.damage(10);\n  obj.damage(20);\n  print('dirty checking!');\n  Observable.dirtyCheck();\n  print('done!');\n}\n</code></pre>\n<p>A more sophisticated approach is to implement the change notification\nmanually. This avoids the potentially expensive Observable.dirtyCheck\noperation, but requires more work in the object:</p>\n<pre><code>import 'package:observe/observe.dart';\nimport 'package:observe/mirrors_used.dart'; // for smaller code\n\nclass Monster extends Unit with ChangeNotifier {\n  int _health = 100;\n  @reflectable get health =&gt; _health;\n  @reflectable set health(val) {\n    _health = notifyPropertyChange(#health, _health, val);\n  }\n\n  void damage(int amount) {\n    print('$this takes $amount damage!');\n    health -= amount;\n  }\n\n  toString() =&gt; 'Monster with $health hit points';\n}\n\nmain() {\n  var obj = new Monster();\n  obj.changes.listen((records) {\n    print('Changes to $obj were: $records');\n  });\n  // Schedules asynchronous delivery of these changes\n  obj.damage(10);\n  obj.damage(20);\n  print('done!');\n}\n</code></pre>\n<p><strong>Note</strong>: by default this package uses mirrors to access getters and setters\nmarked with <code>@reflectable</code>. Dart2js disables tree-shaking if there are any\nuses of mirrors, unless you declare how mirrors are used (via the\n<a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-mirrors.MirrorsUsed\">MirrorsUsed</a>\nannotation).</p>\n<p>As of version 0.10.0, this package doesn't declare <code>@MirrorsUsed</code>. This is\nbecause we intend to use mirrors for development time, but assume that\nframeworks and apps that use this pacakge will either generate code that\nreplaces the use of mirrors, or add the <code>@MirrorsUsed</code> declaration\nthemselves.  For convenience, you can import\n<code>package:observe/mirrors_used.dart</code> as shown on the first example above.\nThat will add a <code>@MirrorsUsed</code> annotation that preserves properties and\nclasses labeled with <code>@reflectable</code> and properties labeled with\n<code>@observable</code>.</p>\n<p>If you are using the <code>package:observe/mirrors_used.dart</code> import, you can\nalso make use of <code>@reflectable</code> on your own classes and dart2js will\npreserve all of its members for reflection.</p>\n<p><a href=\"https://www.dartlang.org/polymer-dart/\">Tools</a> exist to convert the first\nform into the second form automatically, to get the best of both worlds.</p>","variables":{"observable":{"name":"observable","qualifiedName":"observe/observe.observable","comment":"<p>Use <code>@observable</code> to make a field automatically observable, or to indicate\nthat a property is observable.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"observe/observe.ObservableProperty","inner":[]}],"annotations":[]},"reflectable":{"name":"reflectable","qualifiedName":"observe/observe.reflectable","comment":"<p>Use <code>@reflectable</code> to make a type or member available to reflection in the\nobserve package. This is necessary to make the member visible to\nPathObserver, or similar systems, once the code is deployed.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"observe/observe.Reflectable","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"onPropertyChange":{"name":"onPropertyChange","qualifiedName":"observe/observe.onPropertyChange","comment":"<p>Forwards an observable property from one object to another. For example:</p>\n<pre><code>class MyModel extends Observable {\n  StreamSubscription _sub;\n  MyOtherModel _otherModel;\n\n  MyModel() {\n    ...\n    _sub = onPropertyChange(_otherModel, #value,\n        () =&gt; notifyProperty(this, #prop);\n  }\n\n  String get prop =&gt; _otherModel.value;\n  set prop(String value) { _otherModel.value = value; }\n}\n</code></pre>\n<p>See also notifyProperty.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.StreamSubscription","inner":[]}],"parameters":{"source":{"name":"source","optional":false,"named":false,"default":false,"type":[{"outer":"observe/observe.Observable","inner":[]}],"value":null,"annotations":[]},"sourceName":{"name":"sourceName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"toObservable":{"name":"toObservable","qualifiedName":"observe/observe.toObservable","comment":"<p>Converts the <a>dart-core.Iterable</a> or <a>dart-core.Map</a> to an <a>observe/observe.ObservableList</a> or <a>observe/observe.ObservableMap</a>,\nrespectively. This is a convenience function to make it easier to convert\nliterals into the corresponding observable collection type.</p>\n<p>If <a>observe/observe.toObservable.value</a> is not one of those collection types, or is already <a>observe/observe.Observable</a>,\nit will be returned unmodified.</p>\n<p>If <a>observe/observe.toObservable.value</a> is a <a>dart-core.Map</a>, the resulting value will use the appropriate kind of\nbacking map: either <a>observe/dart-core</a>, <a>observe/dart-core</a>, or <a>observe/dart-core</a>.</p>\n<p>By default this performs a deep conversion, but you can set <a>observe/observe.toObservable.deep</a> to false\nfor a shallow conversion. This does not handle circular data structures.\nIf a conversion is peformed, mutations are only observed to the result of\nthis function. Changing the original collection will not affect it.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"deep":{"name":"deep","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Bindable","qualifiedName":"observe/observe.Bindable","preview":"<p>An object that can be data bound.</p>"},{"name":"ChangeNotifier","qualifiedName":"observe/observe.ChangeNotifier","preview":"<p>Mixin and base class for implementing an <a>observe/observe.Observable</a> object that performs\nits own change notifications, and does not need to be considered by\n<a>observe/observe.Observable.dirtyCheck</a>.</p>"},{"name":"ChangeRecord","qualifiedName":"observe/observe.ChangeRecord","preview":"<p>Records a change to an <a>observe/observe.Observable</a>.</p>"},{"name":"CompoundObserver","qualifiedName":"observe/observe.CompoundObserver","preview":"<p><a>observe/observe.CompoundObserver</a> is a <a>observe/observe.Bindable</a> object which knows how to listen to\nmultiple values (registered via <a>observe/observe.CompoundObserver.addPath</a> or <a>observe/observe.CompoundObserver.addObserver</a>) and invoke a\ncallback when one or more of the values have changed.</p>"},{"name":"Indexable","qualifiedName":"observe/observe.Indexable","preview":"<p>An object accepted by <a>observe/observe.PropertyPath</a> where properties are read and written\nas indexing operations, just like a <a>observe/dart-core.Map</a>.</p>"},{"name":"ListChangeRecord","qualifiedName":"observe/observe.ListChangeRecord","preview":"<p>A summary of an individual change to a <a>observe/dart-core.List</a>.</p>"},{"name":"ListPathObserver","qualifiedName":"observe/observe.ListPathObserver","preview":"<p>Observes a path starting from each item in the list.</p>"},{"name":"MapChangeRecord","qualifiedName":"observe/observe.MapChangeRecord"},{"name":"Observable","qualifiedName":"observe/observe.Observable","preview":"<p>Represents an object with observable properties. This is used by data in\nmodel-view architectures to notify interested parties of <a>observe/observe.Observable.changes</a> to the\nobject's properties (fields or getter/setter pairs).</p>"},{"name":"ObservableBox","qualifiedName":"observe/observe.ObservableBox","preview":"<p>An observable box that holds a value. Use this if you want to store a single\nvalue. For other cases, it is better to use <a>observe/observe.ObservableList</a>,\n<a>observe/observe.ObservableMap</a>, or a custom <a>observe/observe.Observable</a> implementation based on\n<a>observe/observe.Observable</a>. The property name for changes is \"value\".</p>"},{"name":"ObservableList","qualifiedName":"observe/observe.ObservableList","preview":"<p>Represents an observable list of model values. If any items are added,\nremoved, or replaced, then observers that are listening to <a>observe/observe.ChangeNotifier.changes</a>\nwill be notified.</p>"},{"name":"ObservableMap","qualifiedName":"observe/observe.ObservableMap","preview":"<p>Represents an observable map of model values. If any items are added,\nremoved, or replaced, then observers that are listening to <a>observe/observe.ChangeNotifier.changes</a>\nwill be notified.</p>"},{"name":"ObservableProperty","qualifiedName":"observe/observe.ObservableProperty","preview":"<p>An annotation that is used to make a property observable.\nNormally this is used via the <a>observe/observe.observable</a> constant, for example:</p>"},{"name":"ObserverTransform","qualifiedName":"observe/observe.ObserverTransform","preview":"<p>ObserverTransform is used to dynamically transform observed value(s).</p>"},{"name":"PathObserver","qualifiedName":"observe/observe.PathObserver","preview":"<p>A data-bound path starting from a view-model or model object, for example\n<code>foo.bar.baz</code>.</p>"},{"name":"PropertyChangeRecord","qualifiedName":"observe/observe.PropertyChangeRecord","preview":"<p>A change record to a field of an observable object.</p>"},{"name":"PropertyPath","qualifiedName":"observe/observe.PropertyPath","preview":"<p>A dot-delimieted property path such as \"foo.bar\" or \"foo.10.bar\".</p>"},{"name":"Reflectable","qualifiedName":"observe/observe.Reflectable","preview":"<p>An annotation that is used to make a type or member reflectable. This makes\nit available to PathObserver at runtime. For example:</p>"}],"typedef":{},"error":[]},"packageName":"observe","packageIntro":""}